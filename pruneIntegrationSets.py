#!/usr/bin/env python3

"""
Script that takes a directory containing .npz files generated by superCorrelator.py
and cleans up any integrations that do not appear to have a full set.
"""

import os
import sys
import glob
import argparse


def main(args):
    # Parse the command line
    if args.directory is None:
        args.directory = '.'
        
    # Validate
    args.directory = os.path.abspath(args.directory)
    if not os.path.exists(args.directory):
        raise RuntimeError("'%s' does not exists" % args.directory)
    if not os.path.isdir(args.directory):
        raise RuntimeError("'%s' is not a directory" % args.directory)
        
    # Find all of the files
    filenames = glob.glob(os.path.join(args.directory, '*-vis2-*.npz'))
    
    # Validate
    if len(filenames) == 0:
        if (not args.quiet):
            print("No integrations found in '%s', exiting" % args.directory)
        sys.exit()
        
    # Find the scan/integration sets
    scans = {}
    for filename in filenames:
        basename = os.path.basename(filename)
        name, _, nint = basename.split('-', 2)
        type, scan, side = name[:-4], name[-4:-1], name[-1]
        nint = nint.split('.', 1)[0]
        
        if scan not in scans:
            scans[scan] = {}
        if nint not in scans[scan]:
            scans[scan][nint] = []
        scans[scan][nint].append( (type, side) )
        
    # Find out what a "typical" integration set looks like
    nInts = []
    for scan in scans:
        nInts.extend( [len(scans[scan][nint]) for nint in scans[scan]] )
    nInts = max(nInts)
    if (not args.quiet):
        print("There appear to be %i files per integration set" % nInts)
        
    # Find bad integration sets that do not have the right number parts
    bad = []
    for scan in scans:
        for nint in scans[scan]:
            if len(scans[scan][nint]) != nInts:
                bad.append( (scan, nint) )
                
    # Move any integration sets that do not ahve the right number of parts
    # into a 'notUsed' directory.
    if bad:
        ## Make sure we have a 'notUsed' directory to populate
        if not os.path.exists(os.path.join(args.directory, 'notUsed')):
            os.mkdir(os.path.join(args.directory, 'notUsed'))
            
        ## Move the files over
        nMoved = 0
        for scan,nint in bad:
            filenames = glob.glob(os.path.join(args.directory, '*%s[HL]-vis2-%s.npz' % (scan, nint)))
            for filename in filenames:
                os.rename(filename, os.path.join(args.directory, 'notUsed', os.path.basename(filename)))
                nMoved += 1
                
        ## Report
        if (not args.quiet):
            badScans = set([scan for scan,nint in bad])
            
            print("Moved %i files corresponding to %i integrations to 'notUsed'" % (nMoved, len(bad)))
            print("Trimmed Scans:")
            for scan in badScans:
                print("  %s" % scan)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='script that takes in a directory and removes integrations where a full set is not present', 
        epilog='NOTE:  If no directory is supplied, the current directory is used.', 
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
        )
    parser.add_argument('directory', type=str, nargs='?', 
                        help='directory to process')
    parser.add_argument('-q', '--quiet', action='store_true', 
                        help='suppress script output')
    args = parser.parse_args()
    main(args)
    
